# 기술 스택 적용 이유

## JPA

* 무엇인가 ?
  * JPA는 Java Persistence API의 약조, 자바 업플리케이션에서 관계형 데이터베이스의 관리를 표준 **명세**이다.
  * 자바 객체와 데이터베이스 테이블 간의 매핑(mapping)를 제공하고, 객체-관계 매핑(ORM, Object-Relational Mapping) 기능을 포함한다.
* 왜 사용하냐 ?
  * 객체 중심의 코드
    * JPA를 사용하면 개발자는 데이터베이스 테이블 대신 자바 객체를 다루면서 개발할 수 있으므로 객체 지향적인 코드를 작성할 수 있습니다.
  * 데이터베이스 중립성
    * JPA는 다양한 관계형 데이터베이스에 대한 쿼리를 자동으로 생성해줍니다. 따라서 특정 데이터베이스에 종속적인 코드를 작성할 필요가 없다.
  * 개발 생산성 향상
    * JPA는 CRUD 작업을 위한 표준화된 API를 제공하기 때문에 , 기본적은 데이터베이스 작업에 대한 코드 작성이 간소화한다.
  * 쿼리 언어 제공
    * JPA는 JPQL(Java Persistence Query Language)이라는 쿼리 언어를 제공하여 , 객체를 기반으로 한 쿼리 작성이 가능하다.
  * 유지보수성:
    * 객체와 테이블 간의 매핑 정보를 별도의 설정 파일이나 어노테이션을 통해 관리하기 때문에 ,변경이 필요할 경우 중앙화된 위치에서 관리가 가능하다.
* 단점
  * 학습 곤선
    * JPA와 ORM에 대한 개념을 처음 배울 때는 다소 복잡하다
  * 성능 이슈
    * JPA는 자동으로 SQL을 생성하므로, 때로는 최적화된 SQL을 직접 작성하는 것보다 비효율적인 SQL이 생성될 수 있다.
  * 복잡한 쿼리
    * 복잡한 쿼리나 특정 데이터베이스의 고유 기능을 사용하려면,JPA의 표준 API를 벗어나 네이티브 SQL을 사용해야 한다.

### JPA(Java Persistence API) vs JDBC(Java Database Connectivity)

#### **JPA (Java Persistence API)**

* **정의**:
  * JPA는 ORM(Object-Relational Mapping) 명세로, 자바 객체와 데이터베이스 테이블 간의 매핑을 지원한다.
* **코드**:
  * 개발자는 객체 중심의 코드를 작성하며, JPA가 이를 SQL로 변환하여 데이터베이스와 상호작용합니다.
* **데이터베이스 중립성**:
  * JPA는 다양한 관계형 데이터베이스를 지원하며, 쿼리 작성에 객체지향적인 언어인 JPQL을 사용할 수 있습니다.
* **CRUD 연산**:
  * CRUD 연산은 JPA가 제공하는 API를 통해 간편하게 수행할 수 있습니다.
* **성능 최적화**:
  * 지연 로딩, 캐싱 등의 기능을 제공하여 성능 최적화가 가능합니다.
* **자동 스키마 생성**:
  * 설정에 따라 데이터베이스 스키마를 자동으로 생성할 수 있습니다.

#### **JDBC (Java Database Connectivity)**

* **정의**:
  * JDBC는 자바와 데이터베이스를 연결하고 상호작용하기 위한 API입니다. 직접적인 SQL 사용이 필요합니다.
* **코드**:
  * 개발자는 SQL 쿼리를 직접 작성하고, JDBC API를 사용하여 데이터베이스와 상호작용합니다.
* **데이터베이스 중립성**:
  * JDBC는 데이터베이스 제품마다 별도의 드라이버가 필요하며, 데이터베이스 특성을 최대한 활용하려면 해당 데이터베이스에 특화된 SQL을 작성해야 할 수 있습니다.
* **CRUD 연산**:
  * 개발자가 직접 SQL을 작성해야 합니다.
* **성능 최적화**:
  * 최적화를 원하면 개발자가 직접 쿼리 최적화와 관련된 작업을 수행해야 합니다.
* **스키마 생성**:
  * 자동화되지 않은 방식으로 스키마를 생성해야 합니다.

#### **결론**

* **JPA**는 객체 **지향적인 프로그래밍**과 데이터베이스 작업을 효과적으로 통합하려는 상황에서 유용하다. 복잡한 쿼리나 최적화가 필요한 경우에는 학습 곡선이 있을 수 있다.
* **JDBC**는 데이터베이스와의 상호작용을 완전히 제어하려는 상황, 또는 단순하고 **직접적인 접근이 필요한 경우**에 유용하다.

## Spring

* 무엇인가 ?
  * Spring은 Java 플랫폼을 위한 엔터프라이즈 애플리케이션 개발 프레임워크이다.
  * 주요 특징 중 하나는 “Inversion of Control(IoC)”이라는 원칙을 기반으로한 경량 컨테이너 제공이다.
* 왜 사용하냐 ?
  * **의존성 주입 (Dependency Injection)**:
    * 간결한 코드를 통한 테스트와 유지 보수의 용이성 제공
  * **통합된 데이터 액세스 프레임워크**:
    * JDBC 및 ORM 프레임워크와의 통합을 통한 데이터베이스 연동의 간소화
  * **선언적 트랜잭션 관리**:
    * 코드 기반의 트랜잭션 관리 대신 선언적 방식을 사용하여 트랜잭션을 관리
  * **모듈화**:
    * 필요한 기능만 선택하여 사용할 수 있게 모듈화되어 있음
  * **다양한 웹 모듈**:
    * RESTful 웹 서비스부터 웹 소켓까지 다양한 웹 관련 기능 제공
* 장단점 무엇인가 ?
  * **장점**:
    * **유연성**:
      * 다양한 모듈과 선택적인 구성을 제공하여 다양한 요구 사항에 대응 가능
    * **테스트 용이성**:
      * 의존성 주입을 통한 객체 간의 느슨한 결합으로 테스트 용이
    * **다양한 데이터 액세스 지원**:
      * JDBC, JPA, JMS 등 다양한 데이터 액세스 기술과의 통합 지원
    * **활발한 커뮤니티와 지원**:
      * 넓은 사용자 베이스와 활발한 커뮤니티 활동
  * **단점**:
    * **학습 곡선**:
      * 많은 기능과 설정을 알아야 하므로 초보자에게는 다소 복잡할 수 있음
    * **오버헤드**:
      * Spring의 다양한 기능과 AOP, 프록시 등의 메커니즘은 때때로 오버헤드를 초래할 수 있음.

## DDD layered architecture

* 무엇인가 ?
  * DDD에서 중요하게 여기는 아키텍처 스타일 중 하나는 '계층형 아키텍처'입니다.
  * 이 계층은 주로 4개의 계층으로 나누어집니다:
    * UI (또는 Presentation)
    * Application
    * Domain
    * Infrastructure.
* 왜 사용하냐 ?
  * **분리와 캡슐화**:
    * 각 계층은 독립적인 책임을 가짐으로써 관심사의 분리를 촉진하고, 유지 보수 및 확장성을 향상시킵니다.
  * **도메인 중심**:
    * 핵심 비즈니스 로직은 도메인 계층에 위치하여, 비즈니스 규칙의 순수성과 중요성을 강조합니다.
  * **재사용성**:
    * 특히 애플리케이션 및 도메인 계층의 로직은 UI나 외부 시스템과 독립적이므로 재사용성이 높아집니다.
* 다른 architecture 무엇이 있는가
  * **Hexagonal Architecture (Port and Adapters)**:
    * 내부와 외부를 연결하는 포트와 어댑터를 중심으로 설계되어 외부 시스템과의 결합을 최소화합니다.
  * **Microservices**:
    * 독립적으로 배포 가능한 작은 서비스들로 구성되어, 각각의 서비스는 독립적인 데이터 저장소와 통신 인터페이스를 가집니다.
  * **Event-Driven Architecture**:
    * 이벤트를 중심으로 시스템 간의 통신을 처리합니다.
  * **CQRS/ES (Command Query Responsibility Segregation/Event Sourcing)**:
    * 명령과 쿼리를 분리하고, 상태 변경을 이벤트로 저장합니다.
* 장단점 무엇인가 ?
  * **장점**:
    * **명확한 경계**:
      * 각 계층의 책임이 명확하므로 설계가 명료하고 코드의 구조를 이해하기 쉽습니다.
    * **유연성**:
      * 각 계층을 독립적으로 수정하거나 교체할 수 있어 유연성이 높습니다.
    * **테스트 용이성**:
      * 각 계층을 독립적으로 테스트할 수 있습니다.
  * **단점**:
    * **오버헤드**:
      * 각 계층간의 호출로 추가적인 오버헤드가 발생할 수 있습니다.
    * **복잡성**:
      * 간단한 애플리케이션에 대해 과도한 설계로 초래 될 수 있습니다.

## 테스트 코드 커버리지 90%

* 무엇인가 ?
  * 테스트 코드 커버리지는 소프트웨어의 소스 코드 중 얼마나 많은 부분이 테스트 케이스에 의해 실행되었는지를 나타내는 지표입니다.
  * 90%의 커버리지는 소스 코드의 90%가 테스트로부터 실행되었다는 것을 의미합니다.
* 왜 해야 하는가 ?
  * **품질 보장**:
    * 높은 커버리지는 코드의 대부분이 테스트에 의해 검증되었다는 것을 나타내므로 소프트웨어의 품질을 더 잘 보장할 수 있습니다.
  * **버그 발견**:
    * 테스트를 통해 코드의 누락 또는 오류를 빨리 발견할 수 있습니다.
  * **리팩토링 용이**:
    * 높은 커버리지를 갖는 테스트는 리팩토링 시 코드 변경에 따른 부작용을 쉽게 발견할 수 있도록 도와줍니다.
  * **개발자의 신뢰도 향상**:
    * 코드 변경 시 높은 커버리지의 테스트가 있으면 개발자는 변경 사항에 대한 더 높은 신뢰도를 가질 수 있습니다.
* 장단점 무엇인가 ?
  * **장점**:
    * **품질 향상**:
      * 소프트웨어의 전반적인 품질이 향상됩니다.
    * **회귀 버그 감소**:
      * 새로운 기능 추가나 기존 코드 변경 시 발생할 수 있는 회귀 버그를 줄일 수 있습니다.
    * **코드 이해도 향상**:
      * 테스트 코드를 작성하고 실행함으로써 코드의 동작을 더 잘 이해할 수 있습니다.
  * **단점**:
    * **과도한 의존**:
      * 커버리지만을 너무 중요시하면 테스트의 질보다 수치에 집중할 위험이 있습니다. 90%의 커버리지가 있더라도 중요한 로직의 테스트가 누락될 수 있습니다.
    * **유지보수 비용**:
      * 테스트 코드도 일종의 코드이므로 유지보수가 필요합니다. 때로는 이로 인한 비용과 시간이 증가할 수 있습니다.
    * **초기 개발 속도 감소**:
      * 테스트 코드를 작성하기 위한 추가적인 시간이 필요하므로 초기 개발 속도가 느려질 수 있습니다.

## DB - mysql

* 왜 사용하냐 ?
  * **성숙함**:
    * MySQL은 오랜 시간 동안 많은 조직과 개발자에게 사용해서 안정성과 신뢰성이 검증되었습니다.
  * **오픈 소스**:
    * MySQL은 오픈 소스 RDBMS로, 무료로 사용할 수 있으며 커뮤니티의 지원을 받을 수 있습니다.
  * **성능**:
    * MySQL은 빠른 속도와 좋은 성능을 제공합니다. 성능 튜닝과 최적화 옵션이 다양하게 제공됩니다.
  * **플랫폼 독립성**:
    * 다양한 운영 체제에서 작동하며 크로스 플랫폼 지원이 가능합니다.
  * **보안**:
    * MySQL은 강력한 보안 기능을 제공하여 데이터의 무결성과 보안성을 유지합니다.
* mysql 선택한 이유
  1. 풍부한 커뮤니티 지원:
     1. MySQL은 전세계적으로 가장 널리 사용되는 오픈소스 RDBMS 중 하나입니다. 이로 인해 풍부한 커뮤니티 지원과 자료를 활용할 수 있습니다.
  2. **성능**:
     1. MySQL은 높은 성능과 안정성을 제공합니다. InnoDB 스토리지 엔진을 사용하면 데이터 무결성 및 트랜잭션 지원도 제공됩니다.
  3. **간단함**:
     1. MySQL은 설치 및 설정이 쉽고, 사용하기 간편합니다.
  4. **통합**:
     1. 많은 웹 애플리케이션과 플랫폼(예: WordPress, Drupal, Joomla 등)은 MySQL을 기본 데이터베이스로 사용합니다.
  5. **비용**:
     1. MySQL은 오픈소스로 제공되므로 초기 비용이 없습니다. (엔터프라이즈 버전에는 비용이 들 수 있음)
  6. **클라우드 호환성**:
     1. AWS RDS, Google Cloud SQL 및 Azure Database와 같은 주요 클라우드 서비스 제공 업체들이 MySQL을 지원합니다.
* 장단점 무엇인가 ?
  * **장점**:
    * **비용 효율적**:
      * 오픈 소스로 무료로 사용할 수 있습니다.
    * **확장성**:
      * 다양한 스케일링 옵션을 제공하여 큰 데이터 세트에 대해 처리할 수 있습니다.
    * **다양한 저장 엔진**:
      * InnoDB, MyISAM, Memory 등 다양한 저장 엔진을 제공하여 다양한 유스케이스에 적합하게 사용할 수 있습니다.
    * **커뮤니티 지원**:
      * 큰 사용자 커뮤니티가 있어 문제 해결에 도움을 받을 수 있습니다.
  * **단점**:
    * **높은 트래픽**:
      * 매우 높은 트래픽의 애플리케이션에는 다른 상용 데이터베이스 시스템들에 비해 한계가 있을 수 있습니다.
    * **고급 기능 부재**:
      * Oracle이나 SQL Server와 같은 상용 RDBMS에 비해 일부 고급 기능이 부족할 수 있습니다.
    * **데이터 웨어하우징**:
      * 대규모의 데이터 웨어하우징 작업에는 최적화되어 있지 않을 수 있습니다.

## Redis

* 무엇인가 ?
  * Redis는 "Remote Dictionary Server"의 약자로, 인메모리 기반의 key-value 구조의 데이터 스토어입니다. 메모리에 데이터를 저장하기 때문에 디스크 기반의 데이터베이스보다 훨씬 빠른 속도로 데이터에 접근할 수 있습니다. 단순한 key-value 저장소를 넘어서 해시, 리스트, 세트, 정렬된 세트 등과 같은 다양한 데이터 구조를 지원합니다.
* 왜 사용하냐 ?
  * **높은 성능**:
    * 메모리 기반이기 때문에 매우 빠른 응답 시간을 가집니다. 이로 인해, 실시간 애플리케이션의 캐시, 세션 저장, 메시지 큐 등 다양한 목적으로 널리 사용됩니다.
  * **데이터 구조의 유연성**:
    * 기본 key-value 저장뿐만 아니라, 리스트, 해시, 세트, 정렬된 세트 등의 복잡한 데이터 구조를 지원합니다.
  * **내결함성**:
    * 데이터의 안전성을 위해 복제, 영속성, 클러스터링 기능을 제공합니다.
  * **원자적 연산**:
    * 모든 Redis 연산은 원자적으로 수행되어, 동시성 문제에서 안전합니다.
* 다른 방법 무엇인가?
  * **Memcached**
    * **장점**:
      * Redis와 유사하게 인메모리 캐싱 시스템. 간단하고 빠른 성능.
    * **단점**:
      * Redis보다 기능적으로 제한적. 복잡한 데이터 구조나 데이터 지속성 등의 기능이 누락.
  * **Apache Kafka**
    * **장점**:
      * 대용량의 실시간 스트림 데이터 처리에 탁월. 메시지 브로커로서의 강력한 성능.
    * **단점**:
      * 단순한 캐싱 목적이나 인메모리 데이터베이스로는 적합하지 않음.
  * **RabbitMQ**
    * **장점**:
      * 메시지 브로커로써 메시지 전달 및 큐잉에 탁월. 다양한 메시징 프로토콜 지원.
    * **단점**:
      * Redis나 Memcached와 같은 인메모리 캐싱 시스템에 비해 설정과 관리가 복잡함.
* 장단점 무엇인가 ?
  * **장점**:
    * 고성능
    * 유연한 데이터 구조
    * 확장성
    * 높은 내결함성
    * 풍부한 클라이언트 라이브러리
  * **단점**:
    * 메모리 기반이기 때문에, 메모리 용량을 초과하는 데이터를 저장할 경우 문제가 발생할 수 있음.
    * 단일 스레드 모델로 인해 CPU 병목이 발생할 수 있음.
    * 올바른 데이터 지속성 설정을 하지 않으면 데이터 손실의 위험이 있음.

## DOCKER

* 무엇인가?
  * Docker는 컨테이너 기반의 오픈 소스 플랫폼입니다.
  * 컨테이너는 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 애플리케이션과 그 종속성을 패키징하는 기술입니다.
  * 이러한 컨테이너를 사용하면 개발자는 어떤 환경에서든 동일하게 동작하는 애플리케이션을 보장할 수 있습니다.
* 왜 사용하냐 ?
  * **일관성**:
    * Docker 컨테이너는 어디서나 동일하게 동작합니다. 로컬에서 개발된 애플리케이션은 테스트, 스테이징 및 프로덕션 환경에서 동일하게 동작합니다.
  * **경량성**:
    * VM과 비교하여 더 적은 리소스를 사용하면서 격리된 환경을 제공합니다.
  * **속도**:
    * 애플리케이션 시작 및 중지가 매우 빠릅니다.
  * **높은 휴대성**:
    * Docker는 클라우드 서비스, 데이터 센터, 개발자의 로컬 머신 등 다양한 환경에서 실행될 수 있습니다.
  * **마이크로서비스 아키텍처와의 호환성**:
    * 컨테이너화된 애플리케이션은 마이크로서비스 아키텍처와 잘 어울립니다.
  * **버전 관리와 재사용성**:
    * Docker 이미지를 버전화하고 공유할 수 있어 재사용성이 높습니다.
* 다른 방법 무엇인가?
  * **가상 머신(VM)**:
    * Hypervisor를 사용하여 하드웨어를 가상화하고 개별 OS 인스턴스를 실행합니다.
  * **기존의 서버 설정 관리 도구**:
    * Chef, Puppet, Ansible 등의 도구를 사용하여 인프라를 코드로 관리합니다.
* 장단점 무엇인가 ?
  * **장점**:
    * **빠른 배포**:
      * 컨테이너는 초 단위로 시작되고 종료될 수 있습니다.
    * **개발-운영 일관성**:
      * 개발자의 로컬 머신에서 테스트, 스테이징 및 프로덕션까지 동일한 환경 제공.
    * **리소스 효율성**:
      * VM보다 더 적은 오버헤드로 많은 애플리케이션을 실행 가능.
    * **마이크로서비스**:
      * 서비스를 작은 단위로 분리하여 운영 가능.
    * **확장성**:
      * 서비스를 쉽게 확장 및 축소 가능.
  * **단점**:
    * **학습 곡선**:
      * Docker와 컨테이너 생태계에 익숙해지는 데 시간이 필요할 수 있습니다.
    * **보안 문제**:
      * 일부 환경에서는 컨테이너 간의 격리가 완전하지 않을 수 있습니다.
    * **기존 도구와의 호환성**:
      * 기존 인프라와 도구와의 통합이 필요할 수 있습니다.
    * **파일 저장 및 데이터 지속성**:
      * 컨테이너의 무상태성으로 인해 지속적인 데이터 저장에 대한 전략이 필요합니다.

## HTTPS

* 무엇인가 ?
  * HTTPS는 "HyperText Transfer Protocol Secure"의 약자로, 웹 서버와 브라우저 간의 통신을 암호화하는 프로토콜입니다.
  * 기본적으로 HTTP에 Secure Socket Layer (SSL) 또는 Transport Layer Security (TLS) 보안 프로토콜을 추가한 것으로 볼 수 있습니다.
  * HTTPS는 웹 트래픽을 암호화하여 중간자 공격 (Man-in-the-Middle Attack)이나 이슬롭 (Eavesdropping) 같은 공격으로부터 데이터를 보호합니다.
* 왜 사용하냐 ?
  * **데이터 보안**:
    * HTTPS는 웹사이트와 사용자 간에 전송되는 데이터를 암호화하여, 외부 공격자가 데이터를 도청하거나 변조하는 것을 막습니다. 이는 특히 개인 정보, 신용 카드 정보, 비밀번호와 같은 민감한 정보를 처리하는 웹사이트에서 중요합니다.
  * **데이터 무결성**:
    * 데이터가 전송 과정에서 변경되거나 손상되지 않았음을 보장합니다.
  * **인증**:
    * 사용자는 HTTPS를 통해 웹사이트의 신뢰도를 확인할 수 있습니다. SSL/TLS 인증서는 공인된 인증 기관 (Certificate Authority, CA)에 의해 발급되며, 사용자에게 웹사이트가 그 주장하는 조직이 맞다는 것을 보장합니다.
  * **SEO 최적화 (Search Engine Optimization)**:
    * 여러 검색 엔진 (특히 Google)은 HTTPS를 사용하는 웹사이트에 더 높은 순위를 부여합니다.
  * **사용자 신뢰도 향상**:
    * 대다수의 웹 브라우저는 HTTPS를 사용하는 웹사이트의 주소창에 자물쇠 아이콘을 표시합니다. 이로 인해 사용자들은 사이트가 안전하다고 느낄 수 있습니다.
  * **웹 기능 확장**:
    * 일부 최신 웹 기능들 (예: HTTP/2, Service Workers)은 HTTPS 상에서만 동작하도록 설계되어 있습니다.
