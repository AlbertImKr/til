# Caching

## 데이터가 변경될 때 캐시의 무효화

### **TTL (Time to Live)**:&#x20;

* 캐시된 데이터는 일정 시간 후 자동으로 만료되도록 TTL 값을 설정할 수 있습니다. 이 방식은 자주 변경되지 않는 데이터나 일정 시간 동안만 유효한 데이터의 경우에 유용합니다.

#### **장점**:

* **자동 만료**:&#x20;
  * 캐시된 데이터가 오래된 경우 자동으로 만료되므로 관리가 간단합니다.
* **리소스 절약**:&#x20;
  * 오래된 또는 더 이상 필요하지 않은 데이터가 메모리에서 자동으로 제거되므로 메모리 사용량을 최적화할 수 있습니다.

#### **단점**:

* **데이터 지연**:&#x20;
  * 만료된 데이터를 다시 로드할 때 지연이 발생할 수 있습니다.
* **잠재적 비효율성**:&#x20;
  * TTL 값이 너무 짧게 설정된 경우, 빈번한 데이터 리로드가 필요하게 될 수 있습니다.

### **쓰기 시 무효화 (Write Through)**:&#x20;

* 데이터를 변경할 때 해당 데이터를 동시에 캐시와 데이터베이스에 모두 쓰는 전략입니다. 이를 통해 데이터의 일관성을 유지할 수 있지만, 쓰기 작업의 지연 시간이 증가할 수 있습니다.

#### **장점**:

* **일관성**:&#x20;
  * 캐시와 데이터베이스 간의 데이터 일관성을 보장합니다.
* **즉각적인 반영**:&#x20;
  * 변경사항이 즉시 캐시와 데이터베이스에 모두 반영됩니다.

#### **단점**:

* **성능 저하**:&#x20;
  * 캐시와 데이터베이스 둘 다에 데이터를 쓰기 때문에 쓰기 작업의 지연 시간이 증가할 수 있습니다.

### **지연 쓰기 (Write Behind)**:&#x20;

* 변경된 데이터를 먼저 캐시에 쓴 후, 일정 시간 뒤에 배치로 데이터베이스에 쓰는 전략입니다. 이 방식은 쓰기 성능을 향상시킬 수 있지만, 데이터베이스에 쓰기 전에 시스템 장애가 발생하면 데이터 손실의 위험이 있습니다.

#### **장점**:

* **높은 성능**:&#x20;
  * 캐시 쓰기가 즉각적으로 이루어지므로 쓰기 성능이 빠릅니다.

#### **단점**:

* **데이터 손실 위험**:&#x20;
  * 데이터베이스에 쓰기 전에 시스템 장애가 발생하면 데이터 손실의 위험이 있습니다.
* **일관성 문제**:
  * &#x20;데이터베이스와 캐시 간의 일시적인 불일치가 발생할 수 있습니다.

### **변경된 부분만 캐시 (Cache Aside)**:&#x20;

* 데이터 변경 시 캐시에서 해당 데이터를 제거하고, 데이터가 다시 필요할 때만 데이터베이스에서 조회하여 캐시에 저장하는 전략입니다. 이 방식은 읽기와 쓰기 작업을 최적화할 수 있습니다.

#### **장점**:

* **최적화된 리소스 사용**:&#x20;
  * 필요한 데이터만 캐시에 로드됩니다.
* **유연성**:&#x20;
  * 어플리케이션 로직에서 데이터를 언제 캐시할지 제어할 수 있습니다.

#### **단점**:

* **초기 지연**:&#x20;
  * 처음 데이터를 로드할 때 추가적인 지연이 발생할 수 있습니다.
* **복잡성 증가**:&#x20;
  * 응용 프로그램 코드에서 캐시 관리를 직접 수행해야 합니다.

### **분산 캐시의 일관성**:&#x20;

* 여러 서버 또는 노드에서 분산 캐시를 사용할 경우, 캐시 간의 일관성을 유지하기 위한 전략이 필요합니다. 예를 들어, 데이터 변경 시 모든 노드의 캐시를 동시에 무효화하거나 특정 노드에서만 캐시를 무효화하는 등의 전략을 적용할 수 있습니다.

#### **장점**:

* **확장성**:&#x20;
  * 분산 캐시를 사용하면 여러 서버 또는 노드에 캐시를 확장할 수 있습니다.

#### **단점**:

* **복잡성**:&#x20;
  * 분산 캐시 간의 일관성을 유지하기 위한 추가적인 전략과 관리가 필요합니다.
* **네트워크 오버헤드**:&#x20;
  * 다른 노드와의 일관성을 유지하기 위한 네트워크 통신으로 인한 추가적인 지연이 발생할 수 있습니다.

## `@CachePut` VS `@CacheEvict`

### `@CachePut`&#x20;

#### **장점**:

* **자동 업데이트**:&#x20;
  * `@CachePut`은 메서드 호출의 결과를 캐시에 자동으로 저장하므로, 캐시의 데이터가 항상 최신 상태로 유지됩니다.
* **데이터 일관성**:&#x20;
  * 데이터를 변경하는 작업 후에 자동으로 캐시를 업데이트하기 때문에 데이터베이스와 캐시 간의 일관성을 유지하기 쉽습니다.

#### **단점**:

* **성능 저하**:&#x20;
  * 데이터베이스와 캐시 둘 다에 데이터를 쓰기 때문에, 쓰기 작업의 지연 시간이 증가할 수 있습니다.
* **불필요한 캐시 업데이트**:&#x20;
  * 모든 업데이트 작업에 대해 캐시를 갱신하므로, 굳이 캐시에 저장할 필요가 없는 데이터까지도 업데이트 될 수 있습니다.

### `@CacheEvict`

#### **장점**:

* **간단한 캐시 관리**:&#x20;
  * 캐시에서 데이터를 간단하게 제거하여, 데이터의 변경 또는 삭제 시 일관성 문제를 피할 수 있습니다.
* **플렉시블**:&#x20;
  * 특정 조건에 따라 캐시를 제거할 수 있으며, 여러 캐시나 전체 캐시를 한 번에 제거하는 것도 가능합니다.
* **리소스 절약**:&#x20;
  * 항상 최신 데이터만 캐시에 유지하면서 캐시 크기를 최소화하여, 리소스를 절약할 수 있습니다.

#### **단점**:

* **빈번한 데이터베이스 조회**:&#x20;
  * 캐시에서 데이터를 제거한 후 해당 데이터가 다시 필요하면 데이터베이스에서 다시 조회해야 하므로, 이로 인한 오버헤드가 발생할 수 있습니다.
* **일시적인 데이터 불일치**:&#x20;
  * 데이터를 업데이트 한 후 캐시에서 해당 데이터를 제거하면, 다음 데이터 요청 시까지는 데이터베이스와 캐시 간의 일시적인 데이터 불일치가 발생할 수 있습니다
