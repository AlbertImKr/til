# Index

## Index는 별도의 테이블

### Index의 본질

* Index는 기본적으로 테이블의 데이터를 참조하는 별도의 데이터 구조다.
* 데이터베이스 내에서 하나의 테이블처럼 관리되며, 원본 데이터 테이블과는 별개로 존재한다.
* Index는 테이블의 특정 컬럼에 대한 빠른 접근을 가능하게 하는 구조다.
* Index 자체도 관리와 유지가 필요한 독립된 데이터 구조다.

## 클러스터 인덱스 (Clustered Index)

### 데이터 위치 결정

* 클러스터 Index는 데이터의 물리적인 저장 위치를 결정하는 키 역할을 한다.

### MySQL에서의 역할

* MySQL에서는 기본 키(Primary Key,PK)가 클러스터 Index 역할을 한다.
* PK 값의 순서대로 데이터가 물리적으로 저장한다.

### 삽입 및 갱신

* 클러스터 키(PK)의 삽입 또는 갱신 시 데이터의 저장 위치가 변경될 수 있다.
* 성능상의 고려가 필요한 부분이다.

### PK 크기의 중요성

* PK의 크기는 Index의 전체 크기를 결정한다.
* 크기가 큰 PK는 Index의 크기를 증가시켜 성능에 영향을 줄 수 있다.

### 예시

* 가상의 `고객` 테이블이 있고, `곡객 ID`가 PK로 설정되어 있다고 가정한다.
* 이 테이블에 클러스터 index가 적용한다.
* `고객 ID`순서대로 데이터가 물리적으로 저장된다.
* 새 고객이 추가되면, 그 고객의 ID에 따라 적절한 위치에 데이터가 저장된다.

## 세컨더리 인덱스 (Secondary Index)

### PK 외 필드 index

* PK가 아닌 다른 필드에 대한 index다.

### 물리적 배열 영향

* 데이터의 물리적 배열에 적접적인 영향을 미친다.

### 데이터 접근

* 세컨더리 index로 데이터를 찾은 후 PK를 통해 실제 데이터에 접근할 수 있다.

### 효율성

* 데이터 분포와 쿼리 특성에 따라 성능이 달라질 수 있다.

### 검색 과정

* 세컨더리 인덱스 검색
* PK 찾기
* PK를 사용한 데이터 접근

### 예시

* 위와 같은 `고객`테이블이다.
* 만약 `성`에 대한 검색이 자주 이루어진다.
* `성`애 대한 세컨더리 index를 생성할 수 있다.
* 이 index를 통해 `성`으로 검색 시, 빠르게 결과를 찾을 수 있으나, 최종적인 데이터에 접근하기 위해서는 PK를 사용하여 해당 고객 레코드를 찾는다.

## Index의 장단점

### 장점

#### 검색 성능 향상

* index는 데이터 검색 속도를 크게 향상시킨다.

#### 정렬 및 그룹화 작업 최적화

* index를 활용하면 데이터 정렬과 그룹화 작업이 더 빨라진다.

#### 조인 성능 향상

* index는 테이블 간의 조인 작업에서도 성능을 개선하는 데 도움을 준다.

### 단점

#### 추가 저장 공간 필요

* index는 추가적인 디스크 공간을 차지한다.

#### 쓰기 작업 성능 저하

* index가 있는 테이블에 데이터를 삽입, 삭제, 갱신하는 경우, index 역시 갱신 되여야 하므로 쓰기 작업이 느려질 수 있다.

#### 관리 오버헤드

* index의 유리 및 관리에 추가적인 리소스가 소요한다.

## index의 트레이드 오프

### 검색 대 쓰기 성능

* index는 검색 성능을 향상시키지만,쓰기 작업(삽입,삭제,수정)에는 부정적인 영향을 줄 수 있다.
* 따라서 읽기가 많은 시나리오에서는 index가 유리하지만 쓰기가 번번한 환경에서는 성능 저하 요인이 될 수 있다.

### 공간 대 성능

* index는 추가적인 디스크 공간을 사용한다. 공간 효율성과 검색 성능 사이에서 적절한 균형을 찾아야 한다.

## index 전략

### index 선택의 중요성

* 모든 컬럼에 index를 생성하는 것은 비효율 적이다.
* 자주 사용되는 검색에 중요한 컬럼에 대해서만 index를 생성해야 한다.

### index 크기 최적화

* index의 크기가 클수록 더 많은 디스크 공간을 차지하고, 메모리 사용량도 증가한다.
* 가능한 index 크기를 최소화하는 것이 중요하다.

### 적절한 index 유형 선택

* B+트리,해시,비트맵 등 다양한 index 유형이 있다.
* 사용 목적과 데이터의 특성에 맞는 index 유형을 선택해야 한다.

### 복합 index 활용

* 여러 컬럼을 기준으로 검색이 자주 이루어지는 경우, 복합 index를 고려할 수 있다.

### index 유지 관리

* 정기적인 index 유지 관리(예: 리빌딩, 리오거나이징)는 index의 성능을 최적화하는 데 필요하다.

#### 성능 모니터링 및 분석

* index의 성능을 지속저긍로 모니터링하고 분석하여 필요에 따라 조정하는 것이 중요하다.

## 추가적인 개념

### Primary Key (PK)

* 각 레이드를 고유하게 식별하는 역할을 한다
* 데이터 접근 및 검색 효율성을 높이기 위해 index로 구현한다.
* PK에 자동으로 index가 생성되며, 데이터 검색 속도를 향상한다.
* 데이터를 PK 순서에 따라 물리적으로 저장하며, 검색과 정령에 효율적이다.

### Foreign Key (FK)

* 다른 테이블의 PK를 참조하여 두 테이블 간의 관계를 형성한다.
* 데이터 관계의 일관성을 유지하기 위해서 참조하는 테이블의 PK를 기반으로 구현한다.
* FK에 index를 적용하면 관련 테이블 간의 조인 작업이 더 효율적으로 이루어진다.

## Relation

[모든 프로그래머가 알아야 할 지연 시간 수치](https://colin-scott.github.io/personal\_website/research/interactive\_latency.html)&#x20;

{% content-ref url="b+-tree.md" %}
[b+-tree.md](b+-tree.md)
{% endcontent-ref %}
